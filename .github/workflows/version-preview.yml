name: Version Preview

on:
  pull_request:
    types: [opened, synchronize]

permissions:
  contents: read
  pull-requests: write

jobs:
  preview:
    name: Preview Version
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0
        
    - name: Analyze commits
      id: analyze
      run: |
        # Get base branch
        BASE_BRANCH="${{ github.event.pull_request.base.ref }}"
        
        # Get commits in PR
        COMMITS=$(git log --pretty=format:"%s" origin/$BASE_BRANCH..HEAD)
        
        # Determine version bump type
        if echo "$COMMITS" | grep -qE "^(feat|feature)(\(.+\))?!:"; then
          BUMP="major"
        elif echo "$COMMITS" | grep -qE "^(feat|feature)(\(.+\))?:"; then
          BUMP="minor"
        elif echo "$COMMITS" | grep -qE "^fix(\(.+\))?:"; then
          BUMP="patch"
        else
          BUMP="patch"
        fi
        
        echo "bump_type=$BUMP" >> $GITHUB_OUTPUT
        
        # Get current version
        CURRENT_VERSION=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
        CURRENT_VERSION=${CURRENT_VERSION#v}
        
        # Calculate next version
        IFS='.' read -ra VERSION_PARTS <<< "$CURRENT_VERSION"
        MAJOR=${VERSION_PARTS[0]:-0}
        MINOR=${VERSION_PARTS[1]:-0}
        PATCH=${VERSION_PARTS[2]:-0}
        
        case $BUMP in
          major)
            NEXT_VERSION="$((MAJOR + 1)).0.0"
            ;;
          minor)
            NEXT_VERSION="${MAJOR}.$((MINOR + 1)).0"
            ;;
          patch)
            NEXT_VERSION="${MAJOR}.${MINOR}.$((PATCH + 1))"
            ;;
        esac
        
        echo "current_version=v$CURRENT_VERSION" >> $GITHUB_OUTPUT
        echo "next_version=v$NEXT_VERSION" >> $GITHUB_OUTPUT
        
    - name: Generate changelog preview
      id: changelog
      run: |
        # Generate changelog from commits
        CHANGELOG=$(git log --pretty=format:"- %s" origin/${{ github.event.pull_request.base.ref }}..HEAD | \
          sed 's/^- feat:/- ✨ Feature:/g' | \
          sed 's/^- fix:/- 🐛 Fix:/g' | \
          sed 's/^- docs:/- 📚 Documentation:/g' | \
          sed 's/^- refactor:/- ♻️ Refactor:/g' | \
          sed 's/^- test:/- ✅ Test:/g' | \
          sed 's/^- perf:/- ⚡ Performance:/g' | \
          sed 's/^- chore:/- 🔧 Chore:/g')
        
        # Store in file to preserve formatting
        echo "$CHANGELOG" > changelog.txt
        
    - name: Comment on PR
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const fs = require('fs');
          const changelog = fs.readFileSync('changelog.txt', 'utf8');
          
          const comment = `## 📦 Version Preview
          
          **Current Version:** \`${{ steps.analyze.outputs.current_version }}\`
          **Next Version:** \`${{ steps.analyze.outputs.next_version }}\` (${steps.analyze.outputs.bump_type} bump)
          
          ### 📝 Changes in this PR:
          ${changelog}
          
          ---
          *This version will be automatically released when this PR is merged to \`${{ github.event.pull_request.base.ref }}\`.*`;
          
          // Find existing comment
          const { data: comments } = await github.rest.issues.listComments({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: context.issue.number,
          });
          
          const botComment = comments.find(comment => 
            comment.user.type === 'Bot' && 
            comment.body.includes('## 📦 Version Preview')
          );
          
          if (botComment) {
            // Update existing comment
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: botComment.id,
              body: comment
            });
          } else {
            // Create new comment
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: comment
            });
          }