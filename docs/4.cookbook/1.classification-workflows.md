---
title: Classification Workflows
description: Real-world classification patterns with zyn
author: zoobzio
published: 2025-12-14
updated: 2025-12-14
tags:
  - cookbook
  - classification
  - patterns
  - examples
---

# Classification Workflows

Real-world patterns for classification tasks.

## Email Triage System

Automatically route incoming emails:

```go
package main

import (
    "context"
    "fmt"

    "github.com/zoobzio/zyn"
    "github.com/zoobzio/zyn/pkg/openai"
)

type EmailRouter struct {
    classifier *zyn.ClassificationSynapse
    urgency    *zyn.ClassificationSynapse
}

func NewEmailRouter(provider zyn.Provider) (*EmailRouter, error) {
    classifier, err := zyn.Classification(
        "Classify email type based on content and subject",
        []string{"support", "sales", "billing", "spam", "personal"},
        provider,
        zyn.WithRetry(2),
    )
    if err != nil {
        return nil, err
    }

    urgency, err := zyn.Classification(
        "Determine urgency level",
        []string{"low", "medium", "high", "critical"},
        provider,
        zyn.WithRetry(2),
    )
    if err != nil {
        return nil, err
    }

    return &EmailRouter{classifier: classifier, urgency: urgency}, nil
}

type RoutingDecision struct {
    Category string
    Urgency  string
    Queue    string
}

func (r *EmailRouter) Route(ctx context.Context, subject, body string) (*RoutingDecision, error) {
    session := zyn.NewSession()
    input := fmt.Sprintf("Subject: %s\n\nBody: %s", subject, body)

    // Classify type
    category, err := r.classifier.Fire(ctx, session, input)
    if err != nil {
        return nil, fmt.Errorf("classification failed: %w", err)
    }

    // Determine urgency (with classification context)
    urgency, err := r.urgency.Fire(ctx, session, "What is the urgency of this email?")
    if err != nil {
        return nil, fmt.Errorf("urgency assessment failed: %w", err)
    }

    return &RoutingDecision{
        Category: category,
        Urgency:  urgency,
        Queue:    determineQueue(category, urgency),
    }, nil
}

func determineQueue(category, urgency string) string {
    if urgency == "critical" {
        return "escalation"
    }
    return category + "-queue"
}
```

## Multi-Level Classification

Hierarchical classification with primary and secondary categories:

```go
type ContentClassifier struct {
    primary   *zyn.ClassificationSynapse
    secondary map[string]*zyn.ClassificationSynapse
}

func NewContentClassifier(provider zyn.Provider) (*ContentClassifier, error) {
    primary, _ := zyn.Classification(
        "Primary content category",
        []string{"technology", "business", "entertainment", "sports"},
        provider,
    )

    // Secondary classifiers per primary category
    secondary := map[string]*zyn.ClassificationSynapse{}

    secondary["technology"], _ = zyn.Classification(
        "Technology subcategory",
        []string{"ai", "cloud", "security", "hardware", "software"},
        provider,
    )

    secondary["business"], _ = zyn.Classification(
        "Business subcategory",
        []string{"finance", "startup", "management", "marketing"},
        provider,
    )

    return &ContentClassifier{primary: primary, secondary: secondary}, nil
}

type Classification struct {
    Primary   string
    Secondary string
}

func (c *ContentClassifier) Classify(ctx context.Context, content string) (*Classification, error) {
    session := zyn.NewSession()

    // Primary classification
    primary, err := c.primary.Fire(ctx, session, content)
    if err != nil {
        return nil, err
    }

    // Secondary classification if available
    var secondary string
    if secondaryClassifier, ok := c.secondary[primary]; ok {
        secondary, err = secondaryClassifier.Fire(ctx, session, "Classify subcategory")
        if err != nil {
            return nil, err
        }
    }

    return &Classification{Primary: primary, Secondary: secondary}, nil
}
```

## Classification with Examples

Improve accuracy with few-shot examples:

```go
func classifyWithExamples(ctx context.Context, provider zyn.Provider, text string) (string, error) {
    classifier, _ := zyn.Classification(
        "Classify customer feedback sentiment",
        []string{"positive", "negative", "neutral", "mixed"},
        provider,
    )

    session := zyn.NewSession()

    // Provide examples through classification input
    input := zyn.ClassificationInput{
        Subject: text,
        Examples: map[string][]string{
            "positive": {
                "Absolutely love this product!",
                "Best purchase I've made all year",
                "Exceeded all my expectations",
            },
            "negative": {
                "Complete waste of money",
                "Terrible experience, would not recommend",
                "Product broke after one day",
            },
            "neutral": {
                "It works as described",
                "Average product, nothing special",
                "Does what it says",
            },
            "mixed": {
                "Good product but expensive",
                "Love the features, hate the interface",
                "Fast shipping but item was damaged",
            },
        },
    }

    return classifier.FireWithInput(ctx, session, input)
}
```

## Batch Classification

Classify multiple items efficiently:

```go
type BatchClassifier struct {
    synapse *zyn.ClassificationSynapse
}

type ClassificationResult struct {
    Input    string
    Category string
    Error    error
}

func (b *BatchClassifier) ClassifyBatch(ctx context.Context, items []string) []ClassificationResult {
    results := make([]ClassificationResult, len(items))

    // Process in parallel with bounded concurrency
    sem := make(chan struct{}, 5)  // Max 5 concurrent
    var wg sync.WaitGroup

    for i, item := range items {
        wg.Add(1)
        go func(idx int, input string) {
            defer wg.Done()
            sem <- struct{}{}
            defer func() { <-sem }()

            session := zyn.NewSession()
            category, err := b.synapse.Fire(ctx, session, input)

            results[idx] = ClassificationResult{
                Input:    input,
                Category: category,
                Error:    err,
            }
        }(i, item)
    }

    wg.Wait()
    return results
}
```

## Classification with Confidence Threshold

Only accept high-confidence classifications:

```go
func classifyWithThreshold(ctx context.Context, synapse *zyn.ClassificationSynapse, input string, threshold float64) (string, error) {
    session := zyn.NewSession()

    result, err := synapse.FireWithDetails(ctx, session, input)
    if err != nil {
        return "", err
    }

    if result.Confidence < threshold {
        return "", fmt.Errorf("confidence %.2f below threshold %.2f", result.Confidence, threshold)
    }

    return result.Primary, nil
}

// Usage
category, err := classifyWithThreshold(ctx, classifier, email, 0.8)
if err != nil {
    // Route to human review
    return routeToHuman(email)
}
```

## Next Steps

- [Extraction Pipelines](./2.extraction-pipelines.md) - Extract structured data
- [Multi-Turn Conversations](./3.multi-turn-conversations.md) - Complex workflows
