---
title: Session
description: Session API reference
author: zoobzio
published: 2025-12-14
updated: 2025-12-14
tags:
  - reference
  - session
  - api
---

# Session

Session manages conversation context across synapse calls.

## Constructor

```go
func NewSession() *Session
```

Create a new empty session.

```go
session := zyn.NewSession()
```

## Read Methods

### Messages

```go
func (s *Session) Messages() []Message
```

Get all messages in the session.

```go
messages := session.Messages()
for _, msg := range messages {
    fmt.Printf("%s: %s\n", msg.Role, msg.Content)
}
```

### Len

```go
func (s *Session) Len() int
```

Get the number of messages.

```go
count := session.Len()
```

### At

```go
func (s *Session) At(index int) (Message, error)
```

Get message at index. Returns error if out of bounds.

```go
msg, err := session.At(0)
if err != nil {
    // Index out of bounds
}
```

### LastUsage

```go
func (s *Session) LastUsage() *TokenUsage
```

Get token usage from the last successful call. Returns nil if no usage recorded.

```go
if usage := session.LastUsage(); usage != nil {
    fmt.Printf("Tokens: %d\n", usage.Total)
}
```

## Write Methods

### Append

```go
func (s *Session) Append(role Role, content string)
```

Add a message to the end.

```go
session.Append(zyn.RoleUser, "Hello")
session.Append(zyn.RoleAssistant, "Hi there!")
```

### Clear

```go
func (s *Session) Clear()
```

Remove all messages.

```go
session.Clear()
```

### Remove

```go
func (s *Session) Remove(index int) error
```

Remove message at index. Returns error if out of bounds.

```go
err := session.Remove(0)
```

### Replace

```go
func (s *Session) Replace(index int, msg Message) error
```

Replace message at index. Returns error if out of bounds.

```go
err := session.Replace(0, zyn.Message{
    Role:    zyn.RoleUser,
    Content: "Updated message",
})
```

### Insert

```go
func (s *Session) Insert(index int, msg Message) error
```

Insert message at index. Returns error if out of bounds.

```go
err := session.Insert(0, zyn.Message{
    Role:    zyn.RoleSystem,
    Content: "You are a helpful assistant",
})
```

## Bulk Methods

### Prune

```go
func (s *Session) Prune(n int) error
```

Remove the last `n` message pairs (user + assistant). Each pair is 2 messages, so `n=1` removes 2 messages. Returns error if `n` is negative.

```go
err := session.Prune(2)  // Remove last 2 exchanges (4 messages)
```

### Truncate

```go
func (s *Session) Truncate(keepFirst, keepLast int) error
```

Keep first `keepFirst` and last `keepLast` messages, remove middle.

```go
err := session.Truncate(2, 2)  // Keep first 2 and last 2
```

### SetMessages

```go
func (s *Session) SetMessages(messages []Message)
```

Replace entire message history.

```go
session.SetMessages([]zyn.Message{
    {Role: zyn.RoleUser, Content: "Summary of previous conversation"},
    {Role: zyn.RoleAssistant, Content: "Acknowledged"},
})
```

### SetUsage

```go
func (s *Session) SetUsage(usage *TokenUsage)
```

Set token usage (typically called internally by synapses).

```go
session.SetUsage(&zyn.TokenUsage{
    Prompt:     100,
    Completion: 50,
    Total:      150,
})
```

## Types

### Message

```go
type Message struct {
    Role    string // RoleUser, RoleAssistant, or RoleSystem
    Content string
}
```

### Role Constants

```go
const (
    RoleUser      = "user"
    RoleAssistant = "assistant"
    RoleSystem    = "system"
)
```

### TokenUsage

```go
type TokenUsage struct {
    Prompt     int
    Completion int
    Total      int
}
```

## Behavior

### Transactional Updates

Synapses update sessions atomically:

```go
session := zyn.NewSession()
initialLen := session.Len()  // 0

_, err := synapse.Fire(ctx, session, "input")
if err != nil {
    // Session unchanged on error
    assert(session.Len() == initialLen)
} else {
    // Session has user message + assistant response
    assert(session.Len() == initialLen + 2)
}
```

### Thread Safety

Sessions are safe for concurrent use by multiple goroutines. All methods are protected by a read-write mutex.

```go
// ✅ OK: Concurrent access
go func() { synapse.Fire(ctx, session, "input1") }()
go func() { synapse.Fire(ctx, session, "input2") }()

// ✅ Also OK: Sequential access
synapse.Fire(ctx, session, "input1")
synapse.Fire(ctx, session, "input2")

// ✅ Also OK: Separate sessions for independent conversations
go func() { synapse.Fire(ctx, zyn.NewSession(), "input1") }()
go func() { synapse.Fire(ctx, zyn.NewSession(), "input2") }()
```

**Note:** While concurrent access is safe, the message ordering in concurrent scenarios depends on which goroutine completes first. For deterministic conversation flow, sequential access is recommended.
